W3c:
w3c是对web做出规范，使代码更严谨，做出来的网页更易使用，维护。
结构上：（标签规范对页面的搜索权重有很大关系，写的越规范网站在搜索排名越靠前）
表现、行为上：
使用外链的css和js脚本，提高页面渲染效率。
少使用行内样式，类名要做到见名知意
H5新特性:
用于绘画 canvas 元素。
本地离线bai存储 localStorage 长期存储数据，浏览器关闭后数据不丢du失；sessionStorage 的数据在浏览器关闭后自动删除。
语意化更好的内容元素，比如 article、footer、header、nav、section。
表单控件，calendar、date、time、email、url、search。
CSS3新特性:
选择器
背景和边框
文本效果
2D/3D 转换
动画、过渡
多列布局
用户界面

兼容内核:
-moz-：代表FireFox浏览器私有属性
-ms-：代表IE浏览器私有属性
-webkit-：代表safari、chrome浏览器私有属性
-o-：代表opera浏览器私有属性


 作用域(scope)和作用域链: 
1. 什么是作用域: 2种解释: 
	(1). 用法: 作用域是一个变量的可用范围
	(2). 本质: 作用域是保存变量的特殊对象
2. 为什么: 避免不同范围的变量之间互相干扰
3. js中包括2种作用域: 
	(1). 全局作用域：
	a. 什么是: 专门保存全局变量的特殊对象——window
	b. 特点: 
		1). 在程序的任何一个角落都可以随时访问到全局作用域。
		2). 全局作用域不会自动释放！除非关闭浏览器窗口。
	c. 什么是全局变量: 保存在全局作用域中，可被程序任何角落随时访问到的变量
	d. 全局变量特点: 2个
		1). 随处可用！——缺点: 极易被污染！
		2). 可反复使用 ——优点
	(2). 函数作用域：
	a. 什么是: 专门保存局部变量的特殊对象——？
	b. 特点: 
		1). 当函数调用时才临时创建函数作用域对象，函数调用后函数作用域对象被自动释放！下次再调用同一个函数，也会重新创建一个全新的函数作用域对象.
		2). 只有函数调用时，函数内的代码才能使用函数作用域对象。
	c. 什么是局部变量: 保存在函数作用域当中，仅函数内的代码可以访问的变量
	d. 局部变量特点: 
		1). 仅函数内可用！——优点: 不会被污染！
		2). 不可重用 ——缺点
4. 作用域链: 
	(1). 什么是作用域链: 由多级作用域，逐级引用，形成的链式结构
	(2). 函数从定义到调用，再到调用完成所经历的过程: 
	a. 定义函数时: 
		1). 创建函数对象保存函数内的代码片段
		2). 每个函数对象身上都有一个"好友列表"，记录了每个函数可用的所有作用域对象，普通函数的好友列表包含2个格子: 
		i. 离函数自己近的格子，暂时预留
		ii. 离函数自己稍远的格子存window。

闭包(closure): 
1. 什么是: 2个概念
	(1). 专门重用一个变量，又保护变量不被篡改一种编程方法
	(2). 本质: 外层函数调用后，外层函数的作用域对象被内层函数引用着，无法释放，形成了闭包对象
2. 为什么: 全局变量和局部变量都有不可兼得的优缺点: 
	(1). 全局变量: 优点: 可重用, 缺点: 随处可用，极易被污染
	(2). 局部变量: 优点: 只能在函数内使用，不会被污染, 缺点: 不可重用
3. 何时: 今后只要想重用一个变量，但是又要保护变量不被篡改，都要用闭包！
4. 如何: 3步 —— 判断闭包的三个特点
	(1). 用外层函数包裹要保护的变量和使用该变量的函数
	(2). 外层函数将内层函数return到外层函数外部，让外部可以使用
	说明: 因为内层函数被返回到外部之后，一定会被外边的变量接住。所以，内层函数没必要起名！就算起了名字，将来外部也不一定使用这个名字！
	(3). 外部要想使用内层函数，必须先调用外层函数，来获得返回的内层函数保存到变量中，才能反复使用！

闭包缺点: 比一般的函数多占用了一块内存空间——外层函数的函数作用域对象
 解决: 一旦一个闭包不再使用，应该立刻释放: 
	保存内层函数的变量=null
		导致内层函数对象被释放
			导致外层函数的作用域对象(闭包)一同被释放

原型链:
	(1). 什么是: 由多级父对象逐级继承形成的链式结构
	(2). 保存着: 子对象可以使用的所有共有的属性和方法
	(3). 控制着: 属性和方法的使用顺序: 先自有，再共有 —— 就近

什么是对象:程序中专门保存现实中一个具体事物的属性和功能的程序结构

封装: 
1. 什么是: 创建一个对象集中保存一个事物的属性和功能
2. 为什么: 便于大量数据的管理和维护
3. 何时: 今后，只要使用面向对象方式编程，都要先创建对象。

继承
1. 自有属性和共有属性
	(1). 什么是: 
	a. 自有属性: 保存在当前子对象内，只归当前子对象自己独有的属性
	b. 共有属性: 保存在原型对象中，归该类型下所有子对象共有的属性
	(2). 何时： 
	a. 如果希望每个子对象都不相同的属性值，应该定义为自有属性
	b. 如果希望多个子对象共用相同的属性值时，应该定义为共有属性
	(3). 如何: 
	a. 所有构造函数中的属性或通过.强行添加给对象的属性都是自有属性
	b. 构造函数.prototype.共有属性=属性值 —— 共有属性
	(4). 坑: 
	a. 想获取属性值则自有属性和共有属性都可用“对象.属性名”
	b. 修改属性值: 
		1). 修改自有属性，必须用子对象.属性名=新值
		2). 修改共有属性，必须用原型对象.属性名=新值
		i. 不能用子对象修改共有属性 —— 不要尝试这样做！no zuo no die!
		ii. 如果用子对象强行修改共有属性: 不会报错
			①js绝不允许子对象直接修改共有属性，所以共有属性保持不变
			②js会自动给当前子对象添加一个和要修改的共有属性同名的自有属性
			结果: 当前子对象在这个共有属性的使用上和其它子对象分道扬镳，再无统一之日。

多态
1. 什么是: 一个函数在不同的情况下表现出不同的状态
2. 重载(overload): 一个函数根据传入的实参值不同，动态选择执行不同的逻辑


CALL
在一次调用函数时，临时替换一次this为指定的对象
	a. 如何: 要调用的函数.call(替换this的对象, 实参值1, 实参值2,...)
	b. 结果: 
		1). 在本次调用函数时，函数中的this会被临时替换为()中指定的任意对象
		2). 将从第二个实参开始往后的所有实参值自动传给要调用的函数的形参变量
APPLY
d. 特殊情况: 如果要调用的函数需要传入多个实参值，但是给定的实参值却是放在一个数组中给的。出现了不一致！
	e. 解决: 用apply()代替call，将实参值数组直接传入apply()
		要调用的函数.apply(替换this的对象, 保存实参值的数组)
	f. 原理: apply比call多一项功能，可自动打散数组为多个实参值，再依次分别传给函数的形参变量。
BIND
基于原函数创建一个新函数副本，并永久替换其中的this
	a. 问题: 如果一个函数每次调用时都要用call()替换this——麻烦
	b. 解决: 创建一个新函数副本，并永久绑定新函数中的this为指定对象
	c. 如何: var 新函数=原函数.bind(替换this的对象, 要固定的实参值)
	d. 原理: bind共做了3件事: 
		1). 基于原函数创建一个一模一样的函数副本
		2). 永久替换新函数副本中的this为指定对象
		3). 永久绑定个别固定的实参值


新MVVM，也将代码分为3部分:
	(1). 界面（View）: 包括以前的HTML+CSS，而且还增强了HTML的功能
	a. 给HTML添加了变量的功能: <span>{{n}}</span> 如果n变化，则span自动变化，无需任何js代码。
	b. 为HTML添加了分支和循环功能: v-if  v-else 以及v-for
	(2). 模型对象(Model): 专门集中保存页面所需的变量和函数的对象
		比如: data和methods都是模型对象
		问题: 模型对象中的变量和方法不会自己长腿跑到界面中的元素上
	(3). 视图模型(ViewModel): 快递员
	a. 什么是视图模型: 自动将data中的变量和methods中的函数送到界面中指定元素上，并能自动保持界面显示与data中变量值同步 一种特殊的对象
	b. 比如: new Vue()就充当了视图模型自动配送的角色。

虚拟DOM树: 
	a. 什么是: vue通过扫描真实DOM树，只提取出个别可能发生变化的元素，组成的一个棵简化版的新的DOM树。
	b. 为什么: 优点： 
		1). 小, 只包含可能受影响的元素，不受影响的元素是不包含在内的
		2). 遍历和查找快！
		3). 更新效率高，因为每次只更新受影响的元素，不受影响的元素，不变的！
		4). 避免重复代码。虚拟DOM树中已经提前封装了DOM增删改查操作！不用我们自己写！
	c. 虚拟DOM树在绑定过程中如何发挥作用： 
		1). new Vue中任何位置修改了data中的变量，其实修改的都是访问器属性
		2). 都会自动触发这个访问器属性的set，都会自动发出通知
		3). new Vue接到通知遍历虚拟DOM树，只找受本次变量修改影响的个别DOM元素
		4). 虚拟DOM树利用已经封装好的增删改查操作，仅更新页面上受影响的个别元素。而不是大范围替换界面元素。—— 效率远高于jQuery！

